---
next:
  text: 'Первый треугольник'
  link: '/guide/getting-started/hello-triangle'
---

# Создание окна

## Первые шаги

Первое, что нам необходимо сделать, прежде чем погружаться в чудесный мир графики - создать окно приложения, в которое
мы будем выводить нашу картинку.

<div class="info custom-block" style="padding-top: 8px">
<p class="custom-block-title">Примечание</p>
<p>
Мы можем использовать графическое API и без окна, рендеря в текстуру и сохраняя ее на диск как изображение. Это будет 
рассмотрено в более поздних разделах.
</p>
</div>

Сложность заключается в том, что у каждой операционной системы для этого надо использовать отдельное API, а у некоторых
даже более одного (Linux, где у каждого оконного сервера оно своё). Вдобавок, нам будет необходимо считывать
пользовательский ввод, такой как движения мыши, нажатия клавиш, а также касания экрана (в случае мобильной игры), что
несет с собой аналогичные проблемы.

К счастью, с этой проблемой уже многие сталкивались, и существуют кроссплатформенные решения. В экосистеме Rust для
этого есть как привязки к популярным библиотекам C++, таким как GLFW и SDL, так и собственное, написанное исключительно
на Rust решение под названием [winit](https://crates.io/crates/winit).

Мы будем использовать winit, поскольку это одновременно и упростит нам настройку и портирование благодаря отсутствию
кода на C++ в зависимостях, и приведет к лучшей совместимости с экосистемой ввиду его подавляющей популярности. Все
популярные проекты на Rust, так или иначе связанные с графикой, в первую очередь поддерживают winit, вне зависимости от
используемого графического API.

Использование именно winit необязательно для освоения данного руководства, вы можете использовать любую библиотеку или
работать без нее. wgpu поддерживает не только winit, но и библиотеку
[raw-window-handle](https://github.com/rust-windowing/raw-window-handle) от его авторов, с которой совместимы все
используемые оконные решения в Rust экосистеме.

## Зависимости проекта

Мы будем добавлять библиотеки по мере необходимости, но для начала обойдемся простым списком. Ниже приведена секция
зависимостей нашего `Cargo.toml`:

```toml [Cargo.toml]
[dependencies]
winit = { version = "0.30" }
wgpu = { version = "24.0" }
tokio = { version = "1.43", features = ["rt"] }
tracing = { version = "0.1" }
tracing-subscriber = { version = "0.3" }
```

<div class="warning custom-block" style="padding-top: 8px">
<p class="custom-block-title">Обратите внимание</p>
<p>
wgpu требует resolver 2 версии для корректной работы. В отдельных крейтах Rust он используется по-умолчанию, начиная с 
2021 издания. Если же у вас более раннее издание, либо вы используете cargo workspace, то необходимо явно его указать
в Cargo.toml
</p>
</div>

Кроме уже упомянутых winit и wgpu, мы будем использовать tokio для выполнения async функций и использования удобных
утилит, необходимых для настройки wgpu и упрощающих реализацию некоторых возможностей. Tokio является решением
по-умолчанию для множества вещей в мире Rust async.

Также очень важны tracing и tracing-subscriber, не только позволяющие нам выводить логи и снимать метрики приложения,
но и включающие вывод отладочной информации и ошибок самой wgpu.

<div class="warning custom-block" style="padding-top: 8px">
<p class="custom-block-title">Обратите внимание</p>
<p>
Если не настроить tracing или какой-либо его аналог, например env-logger, то при критической ошибке внутри wgpu мы не 
увидим подробных сообщений в логах, лишь краткое описание паники.
</p>
</div>

## Следующие действия

<<< @/../code/guide/getting-started/creating-window/src/main.rs#appstate
<<< @/../code/guide/getting-started/creating-window/src/main.rs#appsetup
<<< @/../code/guide/getting-started/creating-window/src/main.rs#centerwindow
<<< @/../code/guide/getting-started/creating-window/src/main.rs#apploop
<<< @/../code/guide/getting-started/creating-window/src/main.rs#main
