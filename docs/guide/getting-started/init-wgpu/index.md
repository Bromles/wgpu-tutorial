---
prev:
  text: "Создание окна"
  link: "/guide/getting-started/creating-window"
next:
  text: "Первый треугольник"
  link: "/guide/getting-started/hello-triangle"
---

# Что такое wgpu

::: details Полный код главы
<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#whole
:::

## Инициализация wgpu

В прошлой главе мы создали окно и базовую структуру приложения с winit. Теперь мы можем инициализировать wgpu и
выполнить простейшую операцию на GPU - заливку окна сплошным цветом.

## Верхнеуровневая схема

Это далеко не полная схема устройства библиотеки, поскольку она была бы слишком сложной для понимания на данном этапе.
Указаны лишь несколько ключевых компонентов, необходимых нам на данный момент

```mermaid
flowchart LR
    Instance --> Adapter
    Adapter --> Device
    Device --> Queue
    Instance --> Surface
    Queue --> GPU
    Surface --> Window[Окно]
```

Кратко поясним каждую сущность на схеме:

- `Instance` - точка входа в wgpu, которую необходимо использовать для начала работы с библиотекой.
- `Adapter` - выбранный графический адаптер, он же GPU. Может быть как физическим, так и логическим. Создается из
  `Instance`.
- `Device` - логическое устройство, управляющее ресурсами GPU, обладающее определенным набором возможностей.
  Запрашивается у адаптера, при этом один адаптер может породить несколько девайсов (например, с разными включенными
  фичами). Используется для создания таких сущностей, как текстуры, буферы, и т.д.
- `Queue` - очередь команд, создаваемая вместе с девайсом и привязанная к нему. Именно ее мы будем использовать для
  отправки операций для выполнения на видеокарте.
- `Surface` - поверхность, привязанная к окну, на которую производится рендеринг. Создается с помощью `Instance`.

## Переходим к коду

Для организации кода создадим структуру `Renderer`, содержащую необходимые на данный момент ресурсы для отрисовки

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer

Из отсутствующего на схеме выше здесь только `SurfaceConfiguration`, которая описывает параметры поверхности, такие как
ее размер и формат изображения. С помощью нее мы реагируем на изменения размера окна, и также можем рендерить не на всё
окно, а лишь в какой-то его области.

`Instance` и `Adapter` хранить не нужно, т.к. на данный момент мы не планируем использование нескольких видеокарт или
разных наборов фич.

Также обновим сущность состояния приложения, чтобы она включала наш объект `Renderer` и флаг необходимости обновления
размера поверхности

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#appstate

<details class="details custom-block" style="padding-top: 8px">
<summary>Примечание</summary>
<code>Renderer</code> здесь завернут в <code>Box</code>, чтобы разные варианты перечисления <code>App</code> не слишком различались по занимаемой памяти (хранение указателя требует ее намного меньше, чем самой структуры). На это есть отдельная <a href="https://rust-lang.github.io/rust-clippy/master/index.html#large_enum_variant">проверка в Clippy</a>
</details>

Наш `Renderer` имеет следующие методы:

```rs
impl Renderer {
    fn new(window: Arc<Window>, runtime: Arc<Runtime>) -> Self;
    fn resize_surface(&self, size: PhysicalSize<u32>);
    fn render(&mut self, window: Arc<Window>);
}
```

Поясним каждый из них:

- `new` - конструктор, создающий новый экземпляр `Renderer`. Принимает указатели на окно и на асинхронный рантайм, так
  как операции запроса `Instance` и `Adapter` требуют асинхронного выполнения из-за совместимости с браузерной средой.
- `resize_surface` - метод, вызываемый при необходимости изменить размеры текущей поверхности. Принимает физический
  размер окна из winit.
- `render` - непосредственно метод отрисовки, принимающий указатель на окно для уведомления winit о скором выводе нового
  кадра. Это необходимо для корректной работы на некоторых платформах, таких как Wayland на Linux, где без данного
  уведомления приложение может быть заблокировано оконным сервером.

## Метод `new`

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-new-size

Здесь мы просто получаем текущий внутренний размер окна и сохраняем его в переменную, предварительно убедившись, что
размеры не равны 0, потому что это привело бы к ошибке при конфигурации поверхности

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-new-instance

Теперь создаем `Instance`. Тут можно увидеть типичный способ создания сущностей wgpu - констукторы принимают объекты
дескрипторов, задающие опции создания. Как правило, такие объекты реализуют трейт `Default`, что позволяет
переопределить лишь необходимые параметры, а остальные оставить по-умолчанию.

Так мы здесь и делаем - задаем только поле `backends` равным `PRIMARY`, что означает поддержку Metal, Vulkan, DirectX 12
и WebGPU. То есть тех нижележащих API, которые позволяют использовать полные возможности wgpu, в отличие от вторичных
бекендов.

Теперь мы получили `Instance` как общую точку входа в API wgpu, и можем приступать к работе с ним.

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-new-surface

Тут производим создание поверхности на основе имеющегося у нас окна winit. Это автоматически привязывает поверхность к
окну

<details class="details custom-block" style="padding-top: 8px">
<summary>Примечание</summary>
Вы могли слышать термины <code>Framebuffer</code> или <code>Swapchain</code>. В некоторых нативных API эти объекты существуют явно, как и в очень старых версиях wgpu. Но сейчас они сокрыты внутри поверхности и не нуждаются в ручном создании или управлении.
</details>

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-new-adapter

Далее запрашиваем адаптер, для чего нам как раз понадобится асинхронный рантайм.

- `power_preference` - задаем приоритеты по энергопотреблению (запрашивать более производительный или более
  энергоэффективный адаптер. Например, интегрированную или дискретную видеокарту у ноутбука)
- `force_fallback_adapter` - отключаем флаг принудительного запроса резервного адаптера, поскольку он обычно не является
  аппаратным, а мы бы хотели использовать настоящую видеокарту
- `compatible_surface` - указываем, что запрашиваемый адаптер должен быть совместим с созданной нами поверхностью.

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-new-device

Переходим к самому главному - созданию девайса и очереди команд, тоже асинхронному.

- `label`- название данного девайса. Подобный параметр присутствует у многих сущностей wgpu. Его можно указывать равным
  `None`, однако осмысленное название в дальнейшем упростит отладку и чтение логов.
- `required_features` - возможности девайса, которые мы запрашиваем. В данном случае мы выбираем те фичи по-умолчанию,
  которые входят в поддерживаемые адаптером
- `required_limits` - запрашиваемые ограничения девайса, такие как максимальный размер текстур, количество одновременно
  используемых буферов, и другие. Запрашиваем ограничения по-умолчанию с учетом доступных ограничений адаптера
- `memory_hints`- подсказки для менеджера памяти ресурсов видеокарты, позволяющие, например, выбрать между
  приоретизацией производительности или потреблением памяти. Сейчас мы выбрали производительность, но это индивидуально
  для каждого проекта
- `trace` - параметры трассировки, позволяющие записать исполняемые команды wgpu в файл для последующего анализа или
  проигрывания с помощью утилиты [wgpu-player](https://github.com/gfx-rs/wgpu/tree/trunk/player). Оставляем по-умолчанию
- `experimental_features` - возможность подключения экспериментальных возможностей. Их включение требует unsafe, нам они
  на данный момент не нужны, поэтому выключаем.

Осталась лишь пара заключительных шагов, а именно - настроить нашу поверхность и создать сам объект `Renderer`.

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-new-surface-config

На данный момент мы упростим себе задачу и создадим конфигурацию поверхности по-умолчанию. Мы просто передаем в нужный
метод адаптер, на базе которого будет создана конфигурация, а также длину и ширину поверхности.

В следующих главах мы научимся создавать свою конфигурацию, чтобы гибко настраивать параметры поверхности, такие как
вертикальная синхронизация.

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-new-return

И, в заключение, мы применяем полученную конфигурацию к поверхности с помощью девайса, конструируем объект `Renderer` и
возвращаем его.

## Метод `resize_surface`

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-resize

Здесь все просто - мы получаем новый размер поверхности как параметр, применяем защиту от нулевых значений, и вызываем
реконфигурацию поверхности, используя девайс и старую конфигурацию

## Метод `render`

Наконец, мы добрались до самого важного - нашего метода для отрисовки на экран.

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-render-texture

Мы начинаем с того, что запрашиваем у поверхности текущую текстуру для отрисовки. Если ее не удалось получить, то мы не
можем обрабатывать текущий кадр.

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-render-encoder

Далее мы создаем кодировщик команд для видеокарты с помощью девайса. Он позволит нам записывать операции, которые потом
будут отправлены в очередь на выполнение

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-render-view

Теперь нам нужно получить представление текущей текстуры, в которое мы будем непосредственно производить отрисовку.
Можно считать это неким аналогом ссылки, понятной для GPU.

Так как нам сейчас не нужно переопределять никакие параметры, используем дескриптор по-умолчанию

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-render-pass

Мы начинаем запись команд для рендера с помощью `begin_render_pass`:

- `label` - то же, что и в других случаях - отладочное название данной сущности
- `color_attachments` - массив представлений текстур, которые будут использоваться в качестве целей рендеринга. В данном
  случае у нас здесь единственная сущность, так как мы рендерим только в одно окно.
    - `view` - ссылка на представление текстуры, в которую будем рендерить
    - `resolve_target` - ссылка на представление текстуры, которое получит результаты мультисэмплинга. Так как мы не
      используем мультисэмплинг, и пока даже не знаем, что это такое, то передаем `None`
    - `ops` - операции, которые будут применены к текстуре перед и после рендеринга. В данном случае мы очищаем текстуру
      перед рендерингом путем заливки ярко зеленым цветом, и сохраняем результат после.
    - `depth_slice` - слайс глубины для 3д текстур. На данный момент нами не используется, поэтому ставим `None`
- `depth_stencil_attachment` - ссылка на представления глубины и трафарета для использования при отрисовке. Ставим
  `None`
- `timestamp_writes` - ссылка на набор меток времени, замеряемых в процессе рендеринга. Так как мы не используем метки
  времени, то передаем `None`
- `occlusion_query_set` - ссылка на набор запросов на определение видимости объектов. Так как мы не используем
  определение видимости, то передаем `None`

В дальнейшем на сущности `RenderPass`, которую мы получили от `begin_render_pass`, мы будем настраивать множество других
параметров. Но на данный момент мы просто хотим залить экран сплошным цветом, поэтому на этом запись команд и
заканчивается.

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-render-finish

Три очень важные операции:

- `queue.submit([encoder.finish()])` - мы завершаем запись команд в кодировщик, получая от него готовый закодированный
  буфер. И тут же передаем его в очередь на исполнение. Этот метод заблокирует наш поток выполнения, пока все переданные
  команды не будут исполнены. Это позволяет не использовать сложную ручную синхронизацию параллельной работы CPU и GPU,
  как в современных нативных API, что помогает избегать множества ошибок. После возврата из этого метода наша текстура
  уже содержит результат рендеринга, но еще не отображается на экране.
- `window.pre_present_notify()` - уже упомянутое уведомление winit о том, что мы собираемся выводить кадр на экран.
- `frame.present()` - непосредственно отправка полученного кадра в виде текстуры на экран. Данный метод также блокирует
  поток выполнения, пока текстура фактически не покажется в окне, что может занять некоторое время из-за особенностей
  работы оконных серверов или забитой очереди на отображение.

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#renderer-render-error

Наконец, вторая ветка match - что мы делаем, если встречаем ошибку при попытке получения текущего кадра из поверхности.

В данном случае мы проверяем тип ошибки - если это превышение потребления памяти, то мы паникуем, поскольку ничего не
можем здесь сделать. В других же ситуациях мы просто запрашиваем повторную отрисовку у окна, то есть у winit, чтобы
попытаться снова на следующем кадре.

## Обновление методов жизненного цикла

### Метод `resumed`

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#appsetup

Мы добавляем создание рантайма tokio в режиме работы на одном потоке, и дальше применяем маленький трюк с окном.

На некоторых системах окно создается с заливкой по-умолчанию, даже если в него ничто не отрисовано. Это выглядит как
мелькнувшее окно одного цвета, прежде чем оно перекрасится нами в нужный. В дальнейшем та же проблема будет преследовать
и при более сложном рендеринге

Для решения данной проблемы мы создаем окно с флагом невидимости, который снимем лишь после отрисовки первого кадра,
чтобы пользователь увидел не, например, просто белый прямоугольник, а уже то, что мы хотим ему показать.

Далее мы используем очень важный метод - выставляем `ControlFlow` для жизненного цикла нашего приложения внутри winit. В
режиме `Wait`, который мы здесь выбрали, исполнение цикла будет приостановлено до тех пор, пока не появятся новые
события. На практике это может выглядеть как замершее окно, которое оживает, когда пользователь двигает мышью (потому
что оно получает события от мыши, например). Нам же это не грозит, поскольку мы самостоятельно запрашиваем повторную
отрисовку там, где она нам нужна, через `window.request_redraw()`. Альтернативные же варианты нас здесь не интересуют,
поскольку мы не собираемся ни ожидать событий с таймаутом, ни исполнять цикл вне зависимости от их наличия

После этого мы создаем наш экземпляр `Renderer` и само состяние приложения.

После чего мы снова деструктурируем текущее состояние, чтобы извлечь `Renderer`, если приложение уже готово, используем
его для единократной отрисовки первого кадра, и делаем окно видимым.

### Метод `window_event`

<<< @/../code/guide/getting-started/init-wgpu/src/main.rs#apploop

Основные изменения в главном цикле приложения:

- Теперь при запросе нового кадра от winit мы не логируем данный факт, а сначала проверяем, нет ли необходимости
  обновить размер поверхности. Если есть - делаем это и снимаем флаг, а далее в любом случае выполняем отрисовку нового
  кадра через наш новый метод `render`
- В обработчик события изменения размера окна добавилось выставление флага на необходимости обновить размер поверхности,
  чтобы при отрисовке следующего кадра мы корректно это обработали.

## Результаты работы

В результате выполнения данного кода мы должны увидеть в центре экрана пустое окно, залитое зеленым цветом. Внешний вид
будет
различаться в зависимости от операционной системы, ниже приведен скриншот с macOS:

![Window](./window.png)

Сам факт успешной отрисовки говорит нам, что мы корректно подключили и использовали wgpu. А отсутствие артефактов при
изменении размера окна показывает, что обработка события и изменение конфигурации поверхности также работают без ошибок.
